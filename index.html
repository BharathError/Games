<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bharath's Neon Odyssey</title>
    <style>
        /* --- CSS STYLING --- */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none; /* Prevent selection on mobile */
            -webkit-user-select: none;
        }

        body {
            background-color: #050505;
            color: white;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden; /* Prevent scrolling */
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI OVERLAYS */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-shadow: 0 0 10px #0ff;
        }

        .score-box {
            font-size: 1.5rem;
            color: #0ff;
        }

        .pilot-info {
            text-align: right;
            color: #f0f;
        }

        .pilot-name {
            font-weight: 900;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 3rem;
            text-transform: uppercase;
            background: linear-gradient(to right, #0ff, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-align: center;
            animation: pulse 2s infinite;
        }

        p {
            font-size: 1.2rem;
            color: #ccc;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }

        button.btn-primary {
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            background: transparent;
            border: 2px solid #0ff;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 0 15px #0ff, inset 0 0 15px #0ff;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        button.btn-primary:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff, inset 0 0 30px #0ff;
            transform: scale(1.1);
        }

        .hidden {
            display: none !important;
        }

        /* ANIMATIONS */
        @keyframes pulse {
            0% { text-shadow: 0 0 10px rgba(0,255,255,0.5); }
            50% { text-shadow: 0 0 30px rgba(0,255,255,0.8), 0 0 10px rgba(255,0,255,0.8); }
            100% { text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .score-box { font-size: 1.2rem; }
            button.btn-primary { padding: 12px 30px; font-size: 1.2rem; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box">SCORE: <span id="scoreEl">0</span></div>
            <div class="pilot-info">
                <div>PILOT</div>
                <div class="pilot-name">BHARATH</div>
                <div style="font-size: 0.8rem; color: #fff;">HP: <span id="hpEl">100</span>%</div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Bharath's<br>Neon Odyssey</h1>
        <p>Command the ship, Pilot Bharath.<br>Defend the galaxy from the void swarm.</p>
        <p style="font-size: 0.9rem; color: #888;">Desktop: Arrow Keys/WASD to Move, Space to Shoot<br>Mobile: Drag to Move (Auto-shoot)</p>
        <button class="btn-primary" id="startBtn">Initialize</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #f00; -webkit-text-fill-color: #f00; text-shadow: 0 0 20px #f00;">MISSION FAILED</h1>
        <p>Good effort, Bharath.<br>Final Score: <span id="finalScoreEl" style="color:#fff; font-weight:bold;">0</span></p>
        <button class="btn-primary" id="restartBtn">Re-Deploy</button>
    </div>
</div>

<script>
/**
 * BHARATH'S NEON ODYSSEY - GAME ENGINE
 * * Features:
 * - Canvas 2D Rendering with Particle Systems
 * - Object Pooling for Performance
 * - Touch & Keyboard Input Unification
 * - Responsive Scaling
 * - Custom Physics for "Drift" feel
 */

// --- CONFIGURATION ---
const CONFIG = {
    playerSpeed: 7,
    playerDrag: 0.92, // Physics drift
    bulletSpeed: 15,
    enemyBaseSpeed: 3,
    spawnRate: 1000, // ms
    particleCount: 15, // Explosion density
    mobileSensitivity: 1.2
};

// --- AUDIO SYNTHESIS (No external files needed) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    if (type === 'shoot') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'explosion') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
}

// --- CANVAS SETUP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let cw, ch;

function resize() {
    cw = canvas.width = window.innerWidth;
    ch = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- GAME STATE ---
let gameActive = false;
let score = 0;
let frames = 0;
let difficultyMultiplier = 1;

// --- INPUT HANDLING ---
const keys = { w: false, a: false, s: false, d: false, space: false };
const mouse = { x: cw / 2, y: ch / 2, active: false }; // For touch drag

window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') keys.w = true;
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.a = true;
    if (e.key === 'ArrowDown' || e.key === 's') keys.s = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.d = true;
    if (e.code === 'Space') keys.space = true;
});

window.addEventListener('keyup', e => {
    if (e.key === 'ArrowUp' || e.key === 'w') keys.w = false;
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.a = false;
    if (e.key === 'ArrowDown' || e.key === 's') keys.s = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.d = false;
    if (e.code === 'Space') keys.space = false;
});

// Mobile Touch
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    mouse.active = true;
    const touch = e.touches[0];
    mouse.x = touch.clientX;
    mouse.y = touch.clientY;
    keys.space = true; // Auto shoot on mobile
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (mouse.active) {
        const touch = e.touches[0];
        mouse.x = touch.clientX;
        mouse.y = touch.clientY;
    }
}, { passive: false });

canvas.addEventListener('touchend', () => {
    mouse.active = false;
    keys.space = false;
});

// --- CLASSES ---

class Player {
    constructor() {
        this.x = cw / 2;
        this.y = ch - 100;
        this.radius = 20;
        this.color = '#0ff';
        this.velocity = { x: 0, y: 0 };
        this.hp = 100;
        this.lastShot = 0;
        this.shootDelay = 15; // Frames
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Glow effect
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;

        // Ship Body
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(0, -this.radius);
        ctx.lineTo(this.radius, this.radius);
        ctx.lineTo(0, this.radius * 0.5); // Engine indent
        ctx.lineTo(-this.radius, this.radius);
        ctx.closePath();
        ctx.fill();

        // Engine Thruster Animation
        if (Math.random() > 0.5) {
            ctx.fillStyle = '#f0f';
            ctx.beginPath();
            ctx.moveTo(-5, this.radius * 0.8);
            ctx.lineTo(5, this.radius * 0.8);
            ctx.lineTo(0, this.radius * 1.5 + Math.random() * 10);
            ctx.fill();
        }
        
        ctx.restore();
    }

    update() {
        // Keyboard Movement with Momentum
        if (keys.w) this.velocity.y -= 1;
        if (keys.s) this.velocity.y += 1;
        if (keys.a) this.velocity.x -= 1;
        if (keys.d) this.velocity.x += 1;

        // Touch Follow Logic (Smooth Lerp)
        if (mouse.active) {
            const dx = mouse.x - this.x;
            const dy = (mouse.y - 50) - this.y; // Offset so finger doesn't cover ship
            this.velocity.x += dx * 0.05;
            this.velocity.y += dy * 0.05;
        }

        // Apply Physics
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.velocity.x *= CONFIG.playerDrag;
        this.velocity.y *= CONFIG.playerDrag;

        // Boundaries
        if (this.x < this.radius) { this.x = this.radius; this.velocity.x *= -0.5; }
        if (this.x > cw - this.radius) { this.x = cw - this.radius; this.velocity.x *= -0.5; }
        if (this.y < this.radius) { this.y = this.radius; this.velocity.y *= -0.5; }
        if (this.y > ch - this.radius) { this.y = ch - this.radius; this.velocity.y *= -0.5; }

        // Shooting
        if (keys.space && frames > this.lastShot + this.shootDelay) {
            bullets.push(new Bullet(this.x, this.y - this.radius));
            playSound('shoot');
            this.lastShot = frames;
            
            // Recoil
            this.y += 2;
        }

        this.draw();
    }
}

class Bullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 4;
        this.color = '#ff0';
        this.markedForDeletion = false;
    }

    draw() {
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    update() {
        this.y -= CONFIG.bulletSpeed;
        if (this.y < 0) this.markedForDeletion = true;
        this.draw();
    }
}

class Enemy {
    constructor() {
        this.radius = Math.random() * 15 + 15;
        this.x = Math.random() * (cw - this.radius * 2) + this.radius;
        this.y = -this.radius - 50;
        
        // Dynamic colors based on type
        const type = Math.random();
        if (type > 0.8) {
            this.color = '#f00'; // Tough
            this.hp = 3;
            this.speed = CONFIG.enemyBaseSpeed * 0.8;
        } else {
            this.color = '#f0f'; // Fast
            this.hp = 1;
            this.speed = CONFIG.enemyBaseSpeed * (1 + Math.random());
        }
        
        this.markedForDeletion = false;
        this.angle = 0;
        this.spin = (Math.random() - 0.5) * 0.1;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        
        // Draw geometric enemy shape
        ctx.beginPath();
        const sides = this.hp === 3 ? 5 : 4; // Pentagon for tough, square for weak
        for (let i = 0; i < sides; i++) {
            const rot = (Math.PI * 2 / sides) * i;
            const px = Math.cos(rot) * this.radius;
            const py = Math.sin(rot) * this.radius;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        
        // Inner Core
        ctx.fillStyle = `rgba(255, 255, 255, ${this.hp / 3})`;
        ctx.fill();
        
        ctx.restore();
    }

    update() {
        this.y += this.speed * difficultyMultiplier;
        this.angle += this.spin;

        if (this.y > ch + this.radius) {
            this.markedForDeletion = true;
            // Penalty for missing enemy?
            score = Math.max(0, score - 50);
            updateHUD();
        }
        this.draw();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 3;
        this.color = color;
        this.velocity = {
            x: (Math.random() - 0.5) * 8,
            y: (Math.random() - 0.5) * 8
        };
        this.alpha = 1;
        this.decay = Math.random() * 0.03 + 0.01;
        this.markedForDeletion = false;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    update() {
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.velocity.x *= 0.95; // Friction
        this.velocity.y *= 0.95;
        this.alpha -= this.decay;

        if (this.alpha <= 0) this.markedForDeletion = true;
        this.draw();
    }
}

class Star {
    constructor() {
        this.x = Math.random() * cw;
        this.y = Math.random() * ch;
        this.radius = Math.random() * 1.5;
        this.speed = Math.random() * 0.5 + 0.1; // Parallax
    }
    
    draw() {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }

    update() {
        this.y += this.speed * (keys.w ? 5 : 1); // Warp speed effect
        if (this.y > ch) {
            this.y = 0;
            this.x = Math.random() * cw;
        }
        this.draw();
    }
}

// --- GLOBAL VARIABLES ---
let player;
let bullets = [];
let enemies = [];
let particles = [];
let stars = [];
let animationId;
let spawnTimer = 0;
let shakeTime = 0;

// --- UTILITIES ---
function init() {
    player = new Player();
    bullets = [];
    enemies = [];
    particles = [];
    stars = [];
    score = 0;
    difficultyMultiplier = 1;
    frames = 0;
    
    // Create Starfield
    for(let i=0; i<100; i++) stars.push(new Star());

    updateHUD();
}

function createExplosion(x, y, color) {
    for (let i = 0; i < CONFIG.particleCount; i++) {
        particles.push(new Particle(x, y, color));
    }
    shakeTime = 10; // Trigger screen shake
    playSound('explosion');
}

function updateHUD() {
    document.getElementById('scoreEl').innerText = score;
    document.getElementById('hpEl').innerText = Math.max(0, player.hp);
}

function endGame() {
    gameActive = false;
    cancelAnimationFrame(animationId);
    document.getElementById('finalScoreEl').innerText = score;
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('ui-layer').classList.add('hidden');
}

// --- MAIN LOOP ---
function animate() {
    if (!gameActive) return;
    animationId = requestAnimationFrame(animate);
    frames++;

    // Clear Canvas
    ctx.fillStyle = 'rgba(5, 5, 5, 0.3)'; // Trail effect
    ctx.fillRect(0, 0, cw, ch);

    // Screen Shake
    ctx.save();
    if (shakeTime > 0) {
        const dx = (Math.random() - 0.5) * 10;
        const dy = (Math.random() - 0.5) * 10;
        ctx.translate(dx, dy);
        shakeTime--;
    }

    // Update Stars (Background)
    stars.forEach(star => star.update());

    // Update Player
    player.update();

    // Update Bullets
    bullets.forEach((bullet, bIndex) => {
        bullet.update();
        if (bullet.markedForDeletion) bullets.splice(bIndex, 1);
    });

    // Update Particles
    particles.forEach((particle, pIndex) => {
        particle.update();
        if (particle.markedForDeletion) particles.splice(pIndex, 1);
    });

    // Spawn Enemies
    if (frames % Math.floor(60 / difficultyMultiplier) === 0) {
        enemies.push(new Enemy());
    }
    // Increase difficulty over time
    if (frames % 600 === 0) difficultyMultiplier += 0.1;

    // Update Enemies & Collision
    enemies.forEach((enemy, eIndex) => {
        enemy.update();

        // Collision: Bullet vs Enemy
        bullets.forEach((bullet, bIndex) => {
            const dist = Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y);
            if (dist - enemy.radius - bullet.radius < 1) {
                // Hit!
                createExplosion(enemy.x, enemy.y, enemy.color);
                enemy.hp--;
                bullet.markedForDeletion = true;
                
                if (enemy.hp <= 0) {
                    enemy.markedForDeletion = true;
                    score += 100;
                    updateHUD();
                }
            }
        });

        // Collision: Enemy vs Player
        const distPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (distPlayer - enemy.radius - player.radius < 1) {
            enemy.markedForDeletion = true;
            createExplosion(player.x, player.y, '#f00');
            player.hp -= 25;
            updateHUD();
            
            if (player.hp <= 0) {
                endGame();
            }
        }

        if (enemy.markedForDeletion) enemies.splice(eIndex, 1);
    });

    ctx.restore(); // Restore from shake
}

// --- INTERFACE EVENTS ---
document.getElementById('startBtn').addEventListener('click', () => {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    init();
    gameActive = true;
    animate();
});

document.getElementById('restartBtn').addEventListener('click', () => {
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    init();
    gameActive = true;
    animate();
});

</script>
</body>
</html>