<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SHADOW RONIN: MOONLIT BLADE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Permanent+Marker&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #0b1016;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated; /* Retro feel */
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 25px;
            width: 100%;
            box-sizing: border-box;
        }

        .stat-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #00f2ff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 32px;
            color: #fff;
            text-shadow: 0 0 10px #00f2ff;
            font-weight: 700;
        }

        /* Spirit Gauge */
        .spirit-bar-container {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #555;
            border-radius: 10px;
            overflow: hidden;
        }

        #spirit-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ff0055, #ff5500);
            box-shadow: 0 0 15px #ff0055;
            transition: width 0.1s linear;
        }

        .spirit-text {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0055;
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0.8;
        }

        /* --- MENU OVERLAY --- */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 16, 22, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .menu-content {
            text-align: center;
            border: 2px solid #00f2ff;
            padding: 50px;
            background: rgba(0, 20, 30, 0.9);
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.2);
            transform: skew(-5deg);
            max-width: 500px;
        }

        h1 {
            font-family: 'Permanent Marker', cursive;
            font-size: 60px;
            margin: 0;
            color: #fff;
            text-shadow: 4px 4px 0px #ff0055;
            transform: rotate(-3deg);
        }

        .subtitle {
            color: #00f2ff;
            margin-bottom: 30px;
            letter-spacing: 4px;
            font-size: 14px;
        }

        .btn {
            background: #fff;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 80%, 90% 100%, 0 100%, 0 20%);
        }

        .btn:hover {
            background: #00f2ff;
            transform: scale(1.05);
            box-shadow: 0 0 30px #00f2ff;
        }

        .controls-hint {
            margin-top: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            text-align: left;
            font-size: 14px;
            color: #888;
        }

        .key-box {
            border: 1px solid #444;
            padding: 5px 10px;
            border-radius: 4px;
            color: #eee;
            font-weight: bold;
            display: inline-block;
            margin-right: 5px;
        }

        /* --- MOBILE CONTROLS --- */
        #mobile-ui {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            z-index: 10;
        }

        .touch-btn {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            backdrop-filter: blur(5px);
            user-select: none;
        }

        #btn-jump { bottom: 40px; left: 40px; }
        #btn-slide { bottom: 40px; left: 140px; }
        #btn-attack { bottom: 60px; right: 40px; border-color: #ff0055; background: rgba(255, 0, 85, 0.2); width: 90px; height: 90px;}

        @media (max-width: 900px) {
            #mobile-ui { display: block; }
            .controls-hint { display: none; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="spirit-bar-container">
            <div id="spirit-fill"></div>
        </div>
        <div class="spirit-text">SPIRIT GAUGE</div>

        <div class="hud-top">
            <div class="stat-container">
                <span class="stat-label">Score</span>
                <span class="stat-value" id="score-val">0</span>
            </div>
            <div class="stat-container" style="align-items: flex-end;">
                <span class="stat-label">Distance</span>
                <span class="stat-value" id="dist-val">0m</span>
            </div>
        </div>

        <div id="mobile-ui">
            <div id="btn-jump" class="touch-btn">▲</div>
            <div id="btn-slide" class="touch-btn">▼</div>
            <div id="btn-attack" class="touch-btn">⚔️</div>
        </div>
    </div>

    <div id="overlay">
        <div class="menu-content">
            <h1>SHADOW<br>RONIN</h1>
            <div class="subtitle">CHAPTER 2: MOONLIT BAMBOO</div>
            <button class="btn" onclick="startGame()">ENTER THE NIGHT</button>
            
            <div class="controls-hint">
                <div>
                    <span class="key-box">SPACE</span> Jump<br>
                    <span class="key-box" style="margin-top:5px; display:inline-block">SPACE x2</span> Double Jump
                </div>
                <div style="text-align: right;">
                    Attack <span class="key-box">F</span><br>
                    Slide <span class="key-box" style="margin-top:5px; display:inline-block">DOWN</span>
                </div>
            </div>
        </div>
    </div>

<script>
    /** * GAME CONFIGURATION & ENGINE
     * ---------------------------
     * A completely rewritten engine focusing on smooth parallax, 
     * readable colors, and fairer difficulty progression.
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Opt for speed

    // --- GLOBAL VARIABLES ---
    let animationId;
    let frames = 0;
    let score = 0;
    let distance = 0;
    let gameSpeed = 5; // Reduced starting speed (was 6/8)
    let isGameOver = true;
    let spirit = 0; // 0 to 100

    // --- INPUT STATE ---
    const keys = {
        space: false,
        down: false,
        f: false
    };

    // --- COLORS PALETTE (Better Contrast) ---
    const PALETTE = {
        bg: '#050810',
        moon: '#e0f7fa',
        bambooDark: '#0d1a12',
        bambooLight: '#1a3322',
        ground: '#080c12',
        accent: '#00f2ff', // Cyan
        danger: '#ff0055', // Neon Pink/Red
        gold: '#ffd700'
    };

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- AUDIO SYSTEM (Placeholder for structure) ---
    const sounds = {
        jump: () => {}, // In a real game, add Audio() here
        slash: () => {},
        hit: () => {}
    };

    // --- INPUT LISTENERS ---
    window.addEventListener('keydown', e => {
        if (isGameOver && e.code === 'Space') startGame();
        if (e.code === 'Space' || e.code === 'ArrowUp') {
            if(!keys.space) player.jump();
            keys.space = true;
        }
        if (e.code === 'ArrowDown') {
            player.slide(true);
            keys.down = true;
        }
        if (e.code === 'KeyF') {
            player.attack();
            keys.f = true;
        }
    });

    window.addEventListener('keyup', e => {
        if (e.code === 'Space' || e.code === 'ArrowUp') keys.space = false;
        if (e.code === 'ArrowDown') {
            player.slide(false);
            keys.down = false;
        }
        if (e.code === 'KeyF') keys.f = false;
    });

    // Touch Handling
    const btnJump = document.getElementById('btn-jump');
    const btnSlide = document.getElementById('btn-slide');
    const btnAttack = document.getElementById('btn-attack');

    btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); player.jump(); });
    btnSlide.addEventListener('touchstart', (e) => { e.preventDefault(); player.slide(true); });
    btnSlide.addEventListener('touchend', (e) => { e.preventDefault(); player.slide(false); });
    btnAttack.addEventListener('touchstart', (e) => { e.preventDefault(); player.attack(); });


    // --- GAME OBJECTS ---

    // 1. BACKGROUND (Parallax System)
    const bgLayers = {
        moon: { x: 0, y: 0 },
        distant: [],
        mid: [],
        foreground: []
    };

    function initBackground() {
        bgLayers.distant = [];
        bgLayers.mid = [];
        // Populate Bamboo Forest
        for(let i=0; i<20; i++) {
            bgLayers.distant.push({
                x: i * 150,
                w: 10 + Math.random() * 20,
                h: canvas.height,
                speed: 0.2
            });
            bgLayers.mid.push({
                x: i * 300,
                w: 20 + Math.random() * 30,
                h: canvas.height,
                speed: 0.5
            });
        }
    }

    function drawBackground() {
        // Clear Sky
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#020205');
        grad.addColorStop(1, '#0b1621');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0, canvas.width, canvas.height);

        // Giant Moon (Fixed position mostly)
        ctx.shadowBlur = 60;
        ctx.shadowColor = 'rgba(224, 247, 250, 0.3)';
        ctx.fillStyle = PALETTE.moon;
        ctx.beginPath();
        ctx.arc(canvas.width - 200, 150, 80, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Distant Bamboo (Darkest)
        ctx.fillStyle = PALETTE.bambooDark;
        bgLayers.distant.forEach(b => {
            b.x -= gameSpeed * b.speed;
            if(b.x + b.w < -50) b.x = canvas.width + 50;
            ctx.fillRect(b.x, 100, b.w, b.h);
            // Segments
            ctx.fillStyle = '#000';
            for(let y=100; y<canvas.height; y+=60) ctx.fillRect(b.x, y, b.w, 2);
            ctx.fillStyle = PALETTE.bambooDark;
        });

        // Mid Bamboo (Lighter)
        ctx.fillStyle = PALETTE.bambooLight;
        bgLayers.mid.forEach(b => {
            b.x -= gameSpeed * b.speed;
            if(b.x + b.w < -50) b.x = canvas.width + 100;
            ctx.fillRect(b.x, 0, b.w, b.h);
             // Leaves
            if(frames % 60 === 0 && Math.random() > 0.5) {
                // Should spawn leaf logic here (omitted for brevity)
            }
        });
    }

    // 2. PLAYER
    const player = {
        x: 100,
        y: 0,
        dy: 0,
        w: 40,
        h: 60,
        grounded: false,
        sliding: false,
        attacking: false,
        attackTimer: 0,
        jumpCount: 0,
        color: '#111',
        scarfPoints: [],

        jump() {
            if (this.grounded) {
                this.dy = -13; // Higher jump for better feel
                this.grounded = false;
                this.jumpCount = 1;
                createParticles(this.x, this.y + this.h, 10, '#888');
            } else if (this.jumpCount < 2) {
                this.dy = -11;
                this.jumpCount++;
                createParticles(this.x, this.y + this.h, 8, PALETTE.accent);
            }
        },

        slide(active) {
            this.sliding = active;
            if (active) {
                this.h = 30; // Shrink hitbox
                if (this.grounded) createParticles(this.x, this.y+30, 1, '#555');
            } else {
                this.h = 60;
            }
        },

        attack() {
            if (!this.attacking) {
                this.attacking = true;
                this.attackTimer = 18; // Frames duration
                sounds.slash();
                
                // Spirit Attack Check
                if (spirit >= 100) {
                    gameSpeed += 5; // Temporary burst
                    setTimeout(() => { gameSpeed -= 5; }, 500);
                    spirit = 0;
                    createParticles(this.x, this.y, 30, PALETTE.accent, 'burst');
                }
            }
        },

        update() {
            // Physics
            this.dy += 0.6; // Gravity
            this.y += this.dy;

            // Ground Collision
            const groundLevel = canvas.height - 100;
            if (this.y + this.h > groundLevel) {
                this.y = groundLevel - this.h;
                this.dy = 0;
                this.grounded = true;
                this.jumpCount = 0;
            } else {
                this.grounded = false;
            }

            // Attack Logic
            if (this.attacking) {
                this.attackTimer--;
                if(this.attackTimer <= 0) this.attacking = false;
            }

            // Spirit Regen
            if (spirit < 100 && frames % 10 === 0) {
                spirit += 0.5;
                document.getElementById('spirit-fill').style.width = spirit + '%';
            }

            // Scarf Physics (Visual)
            this.scarfPoints.unshift({x: this.x, y: this.y + 10});
            if(this.scarfPoints.length > 10) this.scarfPoints.pop();
        },

        draw() {
            ctx.save();
            ctx.translate(this.x + this.w/2, this.y + this.h/2);

            // Scarf Drawing (Trail)
            ctx.beginPath();
            ctx.strokeStyle = PALETTE.danger;
            ctx.lineWidth = 4;
            ctx.moveTo(-10, -15); // Anchor at neck
            this.scarfPoints.forEach((p, i) => {
                const relX = (p.x - this.x - this.w/2) - (gameSpeed * i); // Trail behind
                const relY = (p.y - this.y - this.h/2) + Math.sin(frames*0.5 + i)*5;
                ctx.lineTo(relX, relY);
            });
            ctx.stroke();

            // Ninja Body
            if (this.sliding) {
                ctx.rotate(-0.5); // Tilt back when sliding
                ctx.fillStyle = this.color;
                ctx.fillRect(-20, 0, 50, 20); // Horizontal body
            } else {
                // Running Lean
                const lean = this.grounded ? 0.2 : 0.4;
                ctx.rotate(lean);
                
                // Torso
                ctx.fillStyle = this.color;
                ctx.fillRect(-15, -25, 30, 50);
                
                // Head
                ctx.beginPath();
                ctx.arc(0, -35, 12, 0, Math.PI*2);
                ctx.fill();

                // Eye (Glowing)
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fff';
                ctx.fillRect(2, -38, 8, 4);
                ctx.shadowBlur = 0;
                
                // Headband
                ctx.fillStyle = PALETTE.danger;
                ctx.fillRect(-10, -42, 20, 4);
            }

            // Sword Slash Visual
            if (this.attacking) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(15, 0, 60, -1, 1); // Arc slash
                ctx.stroke();
                
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = PALETTE.accent;
                ctx.lineWidth = 8;
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }
    };

    // 3. ENEMIES & OBSTACLES
    let enemies = [];
    const ENEMY_TYPES = ['SAMURAI', 'YOKAI', 'SPIKES'];

    function spawnEnemy() {
        if (frames % 120 === 0) { // Approx every 2 seconds
            // 20% Chance for nothing, give breathing room
            if (Math.random() > 0.8) return;

            let type = 'SAMURAI';
            if (Math.random() > 0.6) type = 'YOKAI'; // Flying enemy
            
            const groundLevel = canvas.height - 100;
            
            enemies.push({
                type: type,
                x: canvas.width + 50,
                y: type === 'YOKAI' ? groundLevel - 70 - Math.random()*50 : groundLevel - 50,
                w: type === 'SAMURAI' ? 40 : 30,
                h: type === 'SAMURAI' ? 50 : 30,
                active: true,
                floatOffset: Math.random() * 100
            });
        }
    }

    function updateEnemies() {
        enemies.forEach(e => {
            e.x -= gameSpeed;
            
            // Yokai Bobbing motion
            if (e.type === 'YOKAI') {
                e.y += Math.sin((frames + e.floatOffset) * 0.05) * 1.5;
            }

            // Collision Detection
            if (e.active && 
                player.x < e.x + e.w - 10 && 
                player.x + player.w > e.x + 10 &&
                player.y < e.y + e.h - 10 && 
                player.y + player.h > e.y + 10) {
                
                if (player.attacking) {
                    // Successful Kill
                    e.active = false;
                    createParticles(e.x, e.y, 20, e.type === 'YOKAI' ? '#aaddff' : '#990000', 'burst');
                    score += 100;
                    spirit = Math.min(spirit + 10, 100);
                    // Hit stop effect (tiny freeze for impact)
                    // (Omitted for code simplicity, but visual shake added)
                    screenShake = 5;
                } else {
                    // Player Hit
                    gameOver();
                }
            }
        });

        // Cleanup
        enemies = enemies.filter(e => e.x > -100);
    }

    function drawEnemies() {
        enemies.forEach(e => {
            if (!e.active) return;

            if (e.type === 'SAMURAI') {
                // Samurai Silhouette
                ctx.fillStyle = '#220000'; // Dark red/brown
                ctx.fillRect(e.x, e.y, e.w, e.h);
                // Armor highlights
                ctx.fillStyle = '#550000';
                ctx.fillRect(e.x+5, e.y+5, e.w-10, 15); // Chest
                // Eyes
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(e.x+10, e.y+10, 5, 2);
                ctx.fillRect(e.x+25, e.y+10, 5, 2);
            } else if (e.type === 'YOKAI') {
                // Ghost Fire
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'cyan';
                ctx.fillStyle = '#ccffff';
                ctx.beginPath();
                ctx.arc(e.x + e.w/2, e.y + e.h/2, 15, 0, Math.PI*2);
                ctx.fill();
                // Trail
                ctx.beginPath();
                ctx.moveTo(e.x + e.w/2, e.y + e.h/2);
                ctx.lineTo(e.x + e.w + 30, e.y + e.h/2 - 10);
                ctx.lineTo(e.x + e.w + 20, e.y + e.h/2 + 10);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        });
    }

    // 4. PARTICLES ENGINE
    let particles = [];
    function createParticles(x, y, count, color, type='spark') {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color,
                type: type
            });
        }
    }

    function drawParticles() {
        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.03;
            p.vy += 0.2; // Gravity for particles

            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 3, 3);
            ctx.globalAlpha = 1;

            if(p.life <= 0) particles.splice(i, 1);
        });
    }

    // 5. GROUND
    let groundOffset = 0;
    function drawGround() {
        ctx.fillStyle = PALETTE.ground;
        const groundY = canvas.height - 100;
        ctx.fillRect(0, groundY, canvas.width, 100);
        
        // Ground Texture (scrolling)
        ctx.fillStyle = '#111822';
        groundOffset -= gameSpeed;
        if(groundOffset < -50) groundOffset = 0;
        
        for(let i=groundOffset; i<canvas.width; i+=50) {
            ctx.fillRect(i, groundY, 40, 10); // Stones
        }
        
        // Top border line
        ctx.fillStyle = '#00f2ff';
        ctx.fillRect(0, groundY, canvas.width, 2);
    }

    // --- MAIN GAME LOOP ---
    let screenShake = 0;

    function loop() {
        if(isGameOver) return;

        // Logic
        player.update();
        updateEnemies();
        
        distance += gameSpeed * 0.05;
        document.getElementById('dist-val').innerText = Math.floor(distance) + "m";
        document.getElementById('score-val').innerText = score;

        // Speed Progression (Slower ramp up)
        if (gameSpeed < 18) gameSpeed += 0.001; 

        // Drawing
        ctx.clearRect(0,0, canvas.width, canvas.height);
        
        if(screenShake > 0) {
            ctx.save();
            ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
            screenShake *= 0.9;
            if(screenShake < 0.5) screenShake = 0;
        }

        drawBackground();
        drawGround();
        spawnEnemy();
        drawEnemies();
        player.draw();
        drawParticles();

        if(screenShake > 0) ctx.restore();

        // Foreground Effect (Speed Lines at high speed)
        if(gameSpeed > 12) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            for(let i=0; i<5; i++) {
                const lx = Math.random() * canvas.width;
                const ly = Math.random() * canvas.height;
                ctx.fillRect(lx, ly, 100, 2);
            }
        }

        frames++;
        animationId = requestAnimationFrame(loop);
    }

    // --- STATE MANAGEMENT ---
    function startGame() {
        isGameOver = false;
        score = 0;
        distance = 0;
        gameSpeed = 5; // Reset to slow speed
        spirit = 0;
        enemies = [];
        particles = [];
        player.y = 0;
        player.dy = 0;
        
        document.getElementById('overlay').style.opacity = '0';
        setTimeout(() => { document.getElementById('overlay').style.display = 'none'; }, 300);
        
        initBackground();
        loop();
    }

    function gameOver() {
        isGameOver = true;
        cancelAnimationFrame(animationId);
        
        const overlay = document.getElementById('overlay');
        overlay.style.display = 'flex';
        // Need to reflow to allow transition
        setTimeout(() => { overlay.style.opacity = '1'; }, 10);

        document.querySelector('.menu-content h1').innerHTML = "MISSION<br>FAILED";
        document.querySelector('.menu-content .subtitle').innerText = `HONOR: ${score} | DISTANCE: ${Math.floor(distance)}m`;
        document.querySelector('.menu-content .btn').innerText = "TRY AGAIN";
    }

</script>
</body>
</html>
